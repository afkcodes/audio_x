{"version":3,"sources":["../src/constants/common.ts","../src/helpers/common.ts","../src/helpers/notifier.ts","../src/events/errorEvents.ts","../src/events/baseEvents.ts","../src/events/audioEvents.ts","../src/events/listeners.ts","../src/mediasession/mediasessionHandler.ts","../src/states/audioState.ts","../src/audio.ts"],"names":["AUDIO_X_CONSTANTS","Object","freeze","REACT","VANILLA","DEVELOPMENT","PLAYBACK_STATE","BUFFERING","PLAYING","PAUSED","READY","IDLE","ENDED","STALLED","ERROR","ERROR_MSG_MAP","MEDIA_ERR_ABORTED","MEDIA_ERR_DECODE","MEDIA_ERR_NETWORK","MEDIA_ERR_SRC_NOT_SUPPORTED","DEFAULT","isValidArray","__name","arr","Array","isArray","length","isValidFunction","fn","Function","isValidObject","obj","keys","isValidWindow","window","undefined","Window","getReadableErrorMessage","audioInstance","message","error","code","MediaError","metaDataCreator","mediaTrack","title","album","artist","artwork","artworkUrl","src","artworkMap","map","el","sizes","type","listeners","notifierState","_a","ChangeNotifier","notify","eventName","data","caller","listenerCbs","console","log","from","forEach","cb","listen","callback","state","Set","add","callbackArr","push","resetState","notifier_default","ERROR_EVENTS","notifier","BASE_EVENT_CALLBACK_MAP","LOADED_META_DATA","e","playbackState","duration","readable","CAN_PLAY","CAN_PLAY_THROUGH","PLAY","progress","currentTime","PAUSE","errorCode","TIME_UPDATE","WAITING","VOLUME_CHANGE","AUDIO_EVENTS","ABORT","DURATION_CHANGE","EMPTIED","SEEKING","SEEKED","LOADED_DATA","RATE_CHANGE","SUSPEND","PROGRESS","LOAD_START","CUSTOM_AUDIO_EVENTS","AUDIO_X_STATE","attachDefaultEventListeners","eventListenersCallbackMap","AudioX","getAudioInstance","evt","event","addEventListener","listenerCallback","attachCustomEventListeners","eventListenersList","includes","updateMetaData","navigator","mediaSession","metadata","MediaMetadata","attachMediaSessionHandlers","setActionHandler","play","pause","READY_STATE","HAVE_NOTHING","HAVE_METADATA","HAVE_CURRENT_DATA","HAVE_FUTURE_DATA","HAVE_ENOUGH_DATA","AUDIO_STATE","bufferedDuration","volume","playbackRate","currentTrack","constructor","_audio","_instance","warn","process","env","NODE_ENV","Error","Audio","init","initProps","preloadStrategy","autoplay","useDefaultEventListeners","customEventListeners","showNotificationActions","setAttribute","preload","addMedia","source","isSourceAvailable","paused","addMediaAndPlay","then","setTimeout","stop","reset","srcObject","setVolume","actualVolume","setPlaybackRate","mute","muted","seek","time","destroy","removeAttribute","load","subscribe","attachEventListeners","id","getAttribute","media","__publicField"],"mappings":"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","sourcesContent":["import { InitMode } from 'types';\nimport { ErrorMessageMap } from 'types/errorEvents.types';\n\nconst AUDIO_X_CONSTANTS = Object.freeze({\n  REACT: 'REACT' as InitMode,\n  VANILLA: 'VANILLA' as InitMode,\n  DEVELOPMENT: 'development'\n});\n\nconst PLAYBACK_STATE = Object.freeze({\n  BUFFERING: 'buffering',\n  PLAYING: 'playing',\n  PAUSED: 'paused',\n  READY: 'ready',\n  IDLE: 'idle',\n  ENDED: 'ended',\n  STALLED: 'stalled',\n  ERROR: 'error'\n});\n\nconst ERROR_MSG_MAP: ErrorMessageMap = Object.freeze({\n  MEDIA_ERR_ABORTED: 'The user canceled the audio.',\n  MEDIA_ERR_DECODE: 'An error occurred while decoding the audio.',\n  MEDIA_ERR_NETWORK: 'A network error occurred while fetching the audio.',\n  MEDIA_ERR_SRC_NOT_SUPPORTED:\n    'The audio is missing or is in a format not supported by your browser.',\n  DEFAULT: 'An unknown error occurred.'\n});\n\nexport { AUDIO_X_CONSTANTS, ERROR_MSG_MAP, PLAYBACK_STATE };\n","import { ERROR_MSG_MAP } from 'constants/common';\nimport { MediaTrack } from 'types';\n\nconst isValidArray = (arr: any[]) => arr && Array.isArray(arr) && arr.length;\nconst isValidFunction = (fn: any) =>\n  fn instanceof Function && typeof fn === 'function';\n\nconst isValidObject = (obj: any) =>\n  typeof obj === 'object' &&\n  obj !== null &&\n  obj instanceof Object &&\n  Object.keys(obj).length;\n\nconst isValidWindow = typeof window !== undefined && window instanceof Window;\n\nconst getReadableErrorMessage = (audioInstance: HTMLAudioElement) => {\n  let message = '';\n  const err = audioInstance.error;\n\n  switch (err?.code) {\n    case MediaError.MEDIA_ERR_ABORTED:\n      message += ERROR_MSG_MAP['MEDIA_ERR_ABORTED'];\n      break;\n    case MediaError.MEDIA_ERR_NETWORK:\n      message += ERROR_MSG_MAP['MEDIA_ERR_NETWORK'];\n      break;\n    case MediaError.MEDIA_ERR_DECODE:\n      message += ERROR_MSG_MAP['MEDIA_ERR_DECODE'];\n      break;\n    case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:\n      message += ERROR_MSG_MAP['MEDIA_ERR_SRC_NOT_SUPPORTED'];\n      break;\n    default:\n      message += ERROR_MSG_MAP['DEFAULT'];\n      break;\n  }\n\n  return message;\n};\n\nconst metaDataCreator = (mediaTrack: MediaTrack) => {\n  const { title, album, artist, artwork } = mediaTrack;\n  const artworkUrl = artwork ? artwork[0]?.src : '';\n  const sizes = [\n    '96x96',\n    '128x128',\n    '192x192',\n    '256x256',\n    '384x384',\n    '512x512'\n  ];\n  const artworkMap = sizes.map((el) => {\n    return { src: artworkUrl, sizes: el, type: 'image/png' };\n  });\n  const metaData = {\n    title,\n    album,\n    artist,\n    artwork: artworkMap\n  };\n  return metaData;\n};\n\nexport {\n  getReadableErrorMessage,\n  isValidArray,\n  isValidFunction,\n  isValidObject,\n  isValidWindow,\n  metaDataCreator\n};\n","import { isValidArray, isValidFunction, isValidObject } from './common';\n\nconst listeners: any = {};\nexport const notifierState: any = {};\n\nclass ChangeNotifier {\n  /**\n   * this method notifies all the listener attached with the data received.\n   *\n   * @param eventName - Name of the event that the notifier has to notify.\n   * @param data - the data with which the notify method has been called, will notify all the listeners with this data.\n   * @param caller - caller is basically an identifier to know who has made the call to notify.\n   * @returns void\n   */\n\n  static notify(\n    eventName: string,\n    data: any,\n    caller: string = 'audiox_notifier_default'\n  ) {\n    const listenerCbs = listeners[eventName];\n\n    if (!listenerCbs) return;\n\n    if (isValidFunction(listenerCbs as Function) && data !== null) {\n      console.log(`NOTIFYING TO EVENT : ${eventName} - CALLER : ${caller}`);\n\n      /**\n       * checks if the data is object then updates the local\n       * state with the object destructure, if not then assign\n       * the value\n       */\n\n      if (isValidObject(data)) {\n        notifierState[eventName] = { ...notifierState[eventName], ...data };\n      } else {\n        notifierState[eventName] = data;\n      }\n      listenerCbs(notifierState[eventName]);\n    }\n\n    if (isValidArray(Array.from(listenerCbs) as Function[]) && data !== null) {\n      if (isValidObject(data)) {\n        notifierState[eventName] = { ...notifierState[eventName], ...data };\n      } else {\n        notifierState[eventName] = data;\n      }\n      listenerCbs.forEach((cb: Function) => {\n        cb(notifierState[eventName]);\n      });\n    }\n  }\n\n  /**\n   * this method registers a listeners to an event name which it will listen to,\n   * works in conjunction with notify method.\n   *\n   * @param eventName - name of the event for which it will listen to changes\n   * @param callback - any callback that needs to be called once the event is fired\n   * @param state - default state for each event to which it listens to\n   * @returns - a method that unsubscribe the events and basically deletes it\n   */\n\n  static listen(eventName: string, callback: Function, state = {}) {\n    if (!listeners[eventName] && isValidFunction(callback)) {\n      if (!notifierState[eventName]) {\n        notifierState[eventName] = state;\n      }\n      listeners[eventName] = new Set().add(callback);\n    } else {\n      let callbackArr: any = [...listeners[eventName]];\n      listeners[eventName].forEach(() => {\n        callbackArr.push(callback);\n      });\n      listeners[eventName] = new Set(callbackArr);\n    }\n\n    /**\n     * below we are returning the a function that would allow us to remove the listener,\n     * which takes two parameters\n     *\n     * @param caller - identifier name who has made the call to unsubscribe.\n     * @param resetState - a boolean flag which allow if the state needs to be destroyed when the listener is removed.\n     */\n\n    return (caller: string, resetState: boolean) => {\n      if (listeners[eventName]) {\n        console.log(\n          `REMOVING EVENT LISTENER FOR EVENT : ${eventName} - CALLER : ${caller}`\n        );\n        delete listeners[eventName];\n        if (resetState && notifierState[eventName]) {\n          console.log(\n            `RESETTING STATE FOR EVENT : ${eventName} - CALLER : ${caller}`\n          );\n          delete notifierState[eventName];\n        }\n      } else {\n        console.log(`EVENT NOT FOUND : ${eventName}`);\n      }\n    };\n  }\n}\n\nexport default ChangeNotifier;\n","import { ErrorEvents } from 'types/errorEvents.types';\n\nexport const ERROR_EVENTS: ErrorEvents = Object.freeze({\n  1: 'MEDIA_ERR_ABORTED',\n  3: 'MEDIA_ERR_DECODE',\n  2: 'MEDIA_ERR_NETWORK',\n  4: 'MEDIA_ERR_SRC_NOT_SUPPORTED',\n});\n","import { PLAYBACK_STATE } from 'constants/common';\nimport { getReadableErrorMessage } from 'helpers/common';\nimport ChangeNotifier from 'helpers/notifier';\nimport { EventListenerCallbackMap } from 'types';\nimport { ERROR_EVENTS } from './errorEvents';\nconst notifier = ChangeNotifier;\n\nconst BASE_EVENT_CALLBACK_MAP: EventListenerCallbackMap = {\n  LOADED_META_DATA: (e: Event, audioInstance: HTMLAudioElement) => {\n    console.log(e.type);\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.BUFFERING,\n        duration: audioInstance?.duration,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_state_${e.type}`\n    );\n  },\n\n  CAN_PLAY: (e: Event) => {\n    console.log(e.type);\n\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.BUFFERING,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n  },\n\n  CAN_PLAY_THROUGH: (e: Event) => {\n    console.log(e.type);\n\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.READY,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n  },\n\n  PLAY: (e: Event, audioInstance: HTMLAudioElement) => {\n    console.log(e.type);\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.PLAYING,\n        progress: audioInstance?.currentTime,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n  },\n\n  PAUSE: (e: Event, audioInstance: HTMLAudioElement) => {\n    console.log(e.type);\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.PAUSED,\n        progress: audioInstance?.currentTime,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n  },\n\n  ENDED: (e: Event, audioInstance: HTMLAudioElement) => {\n    console.log(e.type);\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.ENDED,\n        progress: audioInstance?.currentTime,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n  },\n\n  ERROR: (e: Event, audioInstance: HTMLAudioElement) => {\n    console.log(e.type);\n    const errorCode = audioInstance.error?.code as keyof typeof ERROR_EVENTS;\n    const message = getReadableErrorMessage(audioInstance);\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.PAUSED,\n        error: {\n          code: errorCode,\n          message: ERROR_EVENTS[errorCode],\n          readable: message\n        }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n  },\n\n  TIME_UPDATE: (e: Event, audioInstance: HTMLAudioElement) => {\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.PLAYING,\n        progress: audioInstance?.currentTime,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n  },\n\n  WAITING: (e: Event, audioInstance: HTMLAudioElement) => {\n    console.log(e.type);\n    notifier.notify(\n      'AUDIO_STATE',\n      {\n        playbackState: PLAYBACK_STATE.BUFFERING,\n        progress: audioInstance?.currentTime,\n        error: { code: null, message: '', readable: '' }\n      },\n      `audiox_baseEvents_state_${e.type}`\n    );\n  },\n\n  VOLUME_CHANGE: (e: Event) => {\n    console.log(e.type);\n    notifier.notify('AUDIO_STATE', {}, `audiox_baseEvents_state`);\n  }\n};\n\nexport { BASE_EVENT_CALLBACK_MAP };\n","import { AudioEvents } from 'types';\n\nexport const AUDIO_EVENTS: AudioEvents = Object.freeze({\n  ABORT: 'abort',\n  TIME_UPDATE: 'timeupdate',\n  CAN_PLAY: 'canplay',\n  CAN_PLAY_THROUGH: 'canplaythrough',\n  DURATION_CHANGE: 'durationchange',\n  ENDED: 'ended',\n  EMPTIED: 'emptied',\n  PLAYING: 'playing',\n  WAITING: 'waiting',\n  SEEKING: 'seeking',\n  SEEKED: 'seeked',\n  LOADED_META_DATA: 'loadedmetadata',\n  LOADED_DATA: 'loadeddata',\n  PLAY: 'play',\n  PAUSE: 'pause',\n  RATE_CHANGE: 'ratechange',\n  VOLUME_CHANGE: 'volumechange',\n  SUSPEND: 'suspend',\n  STALLED: 'stalled',\n  PROGRESS: 'progress',\n  LOAD_START: 'loadstart',\n  ERROR: 'error',\n});\n\nexport const CUSTOM_AUDIO_EVENTS = Object.freeze({\n  AUDIO_X_STATE: 'AUDIO_X_STATE',\n});\n","import { AudioX } from 'audio';\nimport { isValidArray } from 'helpers/common';\nimport ChangeNotifier from 'helpers/notifier';\nimport {\n  AudioEvents,\n  EventListenerCallbackMap,\n  EventListenersList,\n} from 'types/audioEvents.types';\nimport { AUDIO_EVENTS } from './audioEvents';\n\n/**\n * this attaches event listeners, for audio\n */\nconst attachDefaultEventListeners = (\n  eventListenersCallbackMap: EventListenerCallbackMap\n) => {\n  const audioInstance = AudioX.getAudioInstance();\n  isValidArray(Object.keys(eventListenersCallbackMap)) &&\n    Object.keys(eventListenersCallbackMap).forEach((evt) => {\n      let event = evt as keyof AudioEvents;\n      audioInstance?.addEventListener(AUDIO_EVENTS[event], (e: Event) => {\n        if (evt && eventListenersCallbackMap[event]) {\n          const listenerCallback = eventListenersCallbackMap[event];\n          if (typeof listenerCallback === 'function') {\n            listenerCallback(e, audioInstance);\n          }\n        }\n      });\n    });\n};\n\nconst attachCustomEventListeners = (eventListenersList: EventListenersList) => {\n  const audioInstance = AudioX.getAudioInstance();\n  if (isValidArray(eventListenersList)) {\n    eventListenersList.forEach((evt) => {\n      let event = evt as keyof AudioEvents;\n      if (Object.keys(AUDIO_EVENTS).includes(event)) {\n        audioInstance?.addEventListener(AUDIO_EVENTS[event], (e: Event) => {\n          ChangeNotifier.notify(AUDIO_EVENTS[event], { e, audioInstance });\n        });\n      }\n    });\n  }\n};\n\nexport { attachCustomEventListeners, attachDefaultEventListeners };\n","import { AudioX } from 'audio';\nimport { metaDataCreator } from 'helpers/common';\n\nexport const updateMetaData = (data: any) => {\n  if ('mediaSession' in navigator) {\n    navigator.mediaSession.metadata = new MediaMetadata(metaDataCreator(data));\n  }\n};\n\nexport const attachMediaSessionHandlers = () => {\n  if ('mediaSession' in navigator) {\n    navigator.mediaSession.setActionHandler('play', () => {\n      const audioInstance = AudioX.getAudioInstance();\n\n      audioInstance.play();\n    });\n    navigator.mediaSession.setActionHandler('pause', () => {\n      const audioInstance = AudioX.getAudioInstance();\n\n      audioInstance.pause();\n    });\n  }\n};\n","import { PLAYBACK_STATE } from 'constants/common';\nimport ChangeNotifier from 'helpers/notifier';\nimport { ReadyState } from 'types';\nimport { AudioState, MediaTrack } from 'types/audio.types';\n\nexport const READY_STATE: ReadyState = {\n  HAVE_NOTHING: 0,\n  HAVE_METADATA: 1,\n  HAVE_CURRENT_DATA: 2,\n  HAVE_FUTURE_DATA: 3,\n  HAVE_ENOUGH_DATA: 4\n};\n\nexport const AUDIO_STATE: AudioState = {\n  playbackState: PLAYBACK_STATE.IDLE,\n  duration: 0,\n  bufferedDuration: 0,\n  progress: 0,\n  volume: 50,\n  playbackRate: 1,\n  error: {\n    code: null,\n    message: '',\n    readable: ''\n  },\n  currentTrack: {} as MediaTrack\n};\n\n/* Listen to state changes and update global audio state that is being exposed to outer world\n  Do not subscribe to this event, this may cause unexpected behavior instead attach your own custom\n  event listener, if you wish to have granular control on audio state. See: attachCustomEventListener \n*/\nChangeNotifier.listen(\n  'AUDIO_STATE',\n  (data: AudioState) => {\n    ChangeNotifier.notify('AUDIO_X_STATE', { ...AUDIO_STATE, ...data });\n  },\n  AUDIO_STATE\n);\n","import { AUDIO_X_CONSTANTS } from 'constants/common';\nimport { BASE_EVENT_CALLBACK_MAP } from 'events/baseEvents';\nimport {\n  attachCustomEventListeners,\n  attachDefaultEventListeners\n} from 'events/listeners';\nimport ChangeNotifier from 'helpers/notifier';\nimport {\n  attachMediaSessionHandlers,\n  updateMetaData\n} from 'mediasession/mediasessionHandler';\nimport { AUDIO_STATE, READY_STATE } from 'states/audioState';\nimport { EventListenersList, MediaTrack, PlaybackRate } from 'types';\nimport { AudioInit } from 'types/audio.types';\n\nlet audioInstance: HTMLAudioElement;\nconst notifier = ChangeNotifier;\n\nclass AudioX {\n  private _audio: HTMLAudioElement;\n  private static _instance: AudioX;\n\n  constructor() {\n    if (AudioX._instance) {\n      console.warn(\n        'Instantiation failed: cannot create multiple instance of AudioX returning existing instance'\n      );\n      return AudioX._instance;\n    }\n    if (\n      process.env.NODE_ENV !== AUDIO_X_CONSTANTS?.DEVELOPMENT &&\n      audioInstance\n    ) {\n      throw new Error('Cannot create multiple audio instance');\n    }\n\n    AudioX._instance = this;\n    this._audio = new Audio();\n  }\n\n  /**\n   *\n   * @param initProps  initial config to initialize AudioX\n   * @param initProps.mediaTrack mediaTrack Object containing metadata and source of the media\n   * @param initProps.mediaTrack.title title of the Audio\n   * @param initProps.mediaTrack.source URI of the Audio\n   * @param initProps.mediaTrack.artwork artwork of the Audio\n   * @param initProps.mediaTrack.duration  duration of the audio\n   * @param initProps.mediaTrack.genre genre of the audio\n   * @param initProps.mediaTrack.album album of the audio\n   * @param initProps.mediaTrack.comment comment for the audio\n   * @param initProps.mediaTrack.year release year of the audio\n   * @param initProps.mediaTrack.artist artist of the audio\n   * @param mode mode of operation for AudioX\n   * @param autoplay flag for autoplay\n   * @param preloadStrategy strategy for preloading audio\n   * @param playbackRate default playbackRate of the audio\n   * @param attachAudioEventListeners flag for registering audio events\n   * @param attachMediaSessionHandlers flag for registering mediaSession handlers\n   */\n\n  async init(initProps: AudioInit) {\n    const {\n      preloadStrategy = 'auto',\n      autoplay = false,\n      useDefaultEventListeners = true,\n      customEventListeners = null,\n      showNotificationActions = false\n    } = initProps;\n\n    this._audio?.setAttribute('id', 'audio_x_instance');\n    this._audio.preload = preloadStrategy;\n    this._audio.autoplay = autoplay;\n    audioInstance = this._audio;\n\n    if (useDefaultEventListeners || customEventListeners == null) {\n      attachDefaultEventListeners(BASE_EVENT_CALLBACK_MAP);\n    }\n\n    if (showNotificationActions) {\n      attachMediaSessionHandlers();\n    }\n  }\n\n  async addMedia(mediaTrack: MediaTrack) {\n    if (mediaTrack) {\n      audioInstance.src = mediaTrack.source;\n      notifier.notify('AUDIO_STATE', {\n        ...AUDIO_STATE,\n        currentTrack: mediaTrack\n      });\n      updateMetaData(mediaTrack);\n    }\n  }\n\n  async play() {\n    const isSourceAvailable = audioInstance.src !== '';\n    if (\n      audioInstance?.paused &&\n      audioInstance.HAVE_ENOUGH_DATA === READY_STATE.HAVE_ENOUGH_DATA &&\n      isSourceAvailable\n    ) {\n      await audioInstance.play();\n    }\n  }\n\n  /**\n   *\n   * @param mediaTrack MediaTrack to be added and played\n   *\n   * Note: Use this method when you want to add media and do playback or want continuous playback\n   * You can also call addMedia and Play Separately to achieve playback.\n   */\n\n  async addMediaAndPlay(mediaTrack: MediaTrack) {\n    if (mediaTrack) {\n      this.addMedia(mediaTrack).then(() => {\n        if (audioInstance.HAVE_ENOUGH_DATA === READY_STATE.HAVE_ENOUGH_DATA) {\n          setTimeout(async () => {\n            await this.play();\n          }, 950);\n        }\n      });\n    }\n  }\n\n  pause() {\n    if (audioInstance && !audioInstance?.paused) {\n      audioInstance?.pause();\n    }\n  }\n\n  stop() {\n    if (audioInstance && !audioInstance.paused) {\n      audioInstance?.pause();\n      audioInstance.currentTime = 0;\n    }\n  }\n\n  /**\n   * @method reset :  This stops the playback and resets all the state of the audio\n   */\n  async reset() {\n    if (audioInstance) {\n      this.stop();\n      audioInstance.src = '';\n      audioInstance.srcObject = null;\n    }\n  }\n\n  /**\n   * @param volume : numeric value between 1-100 to be used.\n   */\n  setVolume(volume: number) {\n    const actualVolume = volume / 100;\n    if (audioInstance) {\n      audioInstance.volume = actualVolume;\n      notifier.notify('AUDIO_STATE', {\n        ...AUDIO_STATE,\n        volume: volume\n      });\n    }\n  }\n  /**\n   * @param playbackRate : a number denoting speed at which the playback should happen,\n   */\n  setPlaybackRate(playbackRate: PlaybackRate) {\n    if (audioInstance) {\n      audioInstance.playbackRate = playbackRate;\n      notifier.notify('AUDIO_STATE', {\n        ...AUDIO_STATE,\n        playbackRate\n      });\n    }\n  }\n\n  mute() {\n    if (audioInstance && !audioInstance.muted) {\n      audioInstance.muted = true;\n    }\n  }\n\n  seek(time: number) {\n    if (audioInstance) {\n      audioInstance.currentTime = time;\n    }\n  }\n\n  async destroy() {\n    if (audioInstance) {\n      await this.reset();\n      audioInstance.removeAttribute('src');\n      audioInstance.load();\n    }\n  }\n\n  subscribe(eventName: string, callback: Function = () => {}, state: any = {}) {\n    const unsubscribe = notifier.listen(eventName, callback, state);\n    return unsubscribe;\n  }\n\n  attachEventListeners(eventListenersList: EventListenersList) {\n    attachCustomEventListeners(eventListenersList);\n  }\n\n  get id() {\n    return audioInstance?.getAttribute('id');\n  }\n\n  set media(media: MediaTrack) {\n    if (audioInstance) {\n      audioInstance.src = media?.source;\n    }\n    // TODO: implementation metadata\n  }\n\n  static getAudioInstance() {\n    return audioInstance;\n  }\n}\n\nexport { AudioX };\n"]}